// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || 'https://cuumxmfzhwljylbdlflj.supabase.co';

const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN1dW14bWZ6aHdsanlsYmRsZmxqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM1MTkxMjEsImV4cCI6MjA2OTA5NTEyMX0.8jqO_ciOttSxSLZnKY0i5oJmEn79ROF53TjUMYhNemI';

// Request timeout in milliseconds (120 seconds for longer edge function calls like speaking evaluation)
const REQUEST_TIMEOUT = 120000;
const MAX_RETRIES = 3;

// Custom fetch with timeout to prevent hanging requests and retry on connection errors
const fetchWithTimeout = async (url: RequestInfo | URL, options?: RequestInit): Promise<Response> => {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT);

    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal,
      });
      clearTimeout(timeoutId);
      return response;
    } catch (error: any) {
      clearTimeout(timeoutId);
      lastError = error;

      // Don't retry if request was intentionally aborted
      if (error.name === 'AbortError') {
        throw error;
      }

      // Only retry on transient network errors
      const isTransientError =
        error.message === 'Failed to fetch' ||
        error.message?.includes('ERR_CONNECTION_CLOSED') ||
        error.message?.includes('NetworkError') ||
        error.message?.includes('ECONNRESET') ||
        error.message?.includes('ETIMEDOUT');

      if (isTransientError && attempt < MAX_RETRIES) {
        // Exponential backoff: 1s, 2s, 4s
        const delay = Math.pow(2, attempt) * 1000;
        console.log(`ðŸ”„ Retry ${attempt + 1}/${MAX_RETRIES} after ${delay}ms:`, error.message);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }

      // Non-transient error or exhausted retries
      throw error;
    }
  }

  // Should never reach here, but TypeScript needs this
  throw lastError || new Error('Unknown fetch error');
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    flowType: 'pkce',
  },
  global: {
    fetch: fetchWithTimeout,
    headers: {
      'X-Client-Info': 'supabase-js-web',
    }
  }
});

// Create an admin client that includes custom headers for admin operations
// Note: Using a single supabase client instance to avoid "Multiple GoTrueClient instances" warning
// export const adminSupabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
//   auth: {
//     storage: localStorage,
//     persistSession: true,
//     autoRefreshToken: true,
//   },
//   global: {
//     headers: {
//       'X-Admin-Session': localStorage.getItem('admin_session') === 'true' ? 'true' : 'false',
//     },
//   },
// });

// Use the main supabase client for all operations
export const adminSupabase = supabase;