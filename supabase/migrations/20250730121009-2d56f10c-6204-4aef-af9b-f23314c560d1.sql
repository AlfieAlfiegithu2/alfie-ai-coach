-- Database Refactor: Complete Schema Migration
-- Step 1: Backup existing valuable data
CREATE TABLE IF NOT EXISTS temp_tests_backup AS 
SELECT * FROM tests WHERE total_questions > 0;

CREATE TABLE IF NOT EXISTS temp_questions_backup AS 
SELECT * FROM questions WHERE question_text IS NOT NULL AND question_text != '';

-- Step 2: Drop all legacy tables completely
DROP TABLE IF EXISTS reading_questions CASCADE;
DROP TABLE IF EXISTS listening_questions CASCADE;
DROP TABLE IF EXISTS reading_passages CASCADE;
DROP TABLE IF EXISTS listening_sections CASCADE;
DROP TABLE IF EXISTS ielts_reading_tests CASCADE;
DROP TABLE IF EXISTS general_questions CASCADE;
DROP TABLE IF EXISTS general_passages CASCADE;
DROP TABLE IF EXISTS general_listening_questions CASCADE;
DROP TABLE IF EXISTS general_listening_sections CASCADE;
DROP TABLE IF EXISTS pte_questions CASCADE;
DROP TABLE IF EXISTS pte_passages CASCADE;
DROP TABLE IF EXISTS pte_listening_questions CASCADE;
DROP TABLE IF EXISTS pte_listening_sections CASCADE;
DROP TABLE IF EXISTS toefl_questions CASCADE;
DROP TABLE IF EXISTS toefl_passages CASCADE;
DROP TABLE IF EXISTS toefl_listening_questions CASCADE;
DROP TABLE IF EXISTS toefl_listening_sections CASCADE;

-- Step 3: Drop existing universal tables to recreate them clean
DROP TABLE IF EXISTS questions CASCADE;
DROP TABLE IF EXISTS tests CASCADE;
DROP TABLE IF EXISTS user_analytics CASCADE;

-- Step 4: Create the new, clean universal schema

-- Universal Tests Table (The Container for All Tests)
CREATE TABLE public.tests (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    test_name text NOT NULL, -- e.g., "IELTS Reading Test 1"
    test_type text NOT NULL, -- e.g., "IELTS", "PTE"
    module text NOT NULL, -- e.g., "Reading", "Listening"
    created_at timestamptz NOT NULL DEFAULT now()
);

-- Universal Questions Table (Holds All Questions for All Tests)
CREATE TABLE public.questions (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    test_id uuid NOT NULL REFERENCES public.tests(id) ON DELETE CASCADE,
    part_number integer NOT NULL,
    question_number_in_part integer NOT NULL,
    question_text text NOT NULL,
    question_type text NOT NULL,
    choices text,
    correct_answer text NOT NULL,
    explanation text,
    passage_text text,
    audio_url text,
    image_url text,
    transcription text,
    created_at timestamptz NOT NULL DEFAULT now()
);

-- Clean up and recreate profiles table
DROP TABLE IF EXISTS profiles CASCADE;
CREATE TABLE public.profiles (
    id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
    full_name text,
    subscription_status text DEFAULT 'free'::text,
    native_language text DEFAULT 'English'::text,
    created_at timestamptz DEFAULT now()
);

-- User Analytics Table
CREATE TABLE public.user_analytics (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    action_type text NOT NULL,
    details jsonb,
    created_at timestamptz NOT NULL DEFAULT now()
);

-- Step 5: Add Performance Indexes
CREATE INDEX idx_questions_test_id ON public.questions(test_id);
CREATE INDEX idx_analytics_user_id ON public.user_analytics(user_id);
CREATE INDEX idx_questions_part_number ON public.questions(part_number);
CREATE INDEX idx_tests_type_module ON public.tests(test_type, module);

-- Step 6: Enable Row Level Security
ALTER TABLE public.tests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.questions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_analytics ENABLE ROW LEVEL SECURITY;

-- Step 7: Create RLS Policies

-- Tests policies
CREATE POLICY "Tests are viewable by everyone" ON public.tests FOR SELECT USING (true);
CREATE POLICY "Only admins can manage tests" ON public.tests FOR ALL USING (false) WITH CHECK (false);

-- Questions policies  
CREATE POLICY "Questions are viewable by everyone" ON public.questions FOR SELECT USING (true);
CREATE POLICY "Only admins can manage questions" ON public.questions FOR ALL USING (false) WITH CHECK (false);

-- Profiles policies
CREATE POLICY "Users can view own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can insert own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Analytics policies
CREATE POLICY "Users can insert own analytics" ON public.user_analytics FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can view own analytics" ON public.user_analytics FOR SELECT USING (auth.uid() = user_id);

-- Step 8: Create trigger for profile creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name)
  VALUES (NEW.id, COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.email));
  RETURN NEW;
END;
$$;

CREATE OR REPLACE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Step 9: Restore valuable data from backup
INSERT INTO public.tests (test_name, test_type, module, created_at)
SELECT 
  COALESCE(test_name, 'Test ' || test_number::text),
  COALESCE(test_type, 'IELTS'),
  COALESCE(module, 'Reading'),
  created_at
FROM temp_tests_backup
WHERE test_name IS NOT NULL;

-- Step 10: Clean up backup tables
DROP TABLE IF EXISTS temp_tests_backup;
DROP TABLE IF EXISTS temp_questions_backup;